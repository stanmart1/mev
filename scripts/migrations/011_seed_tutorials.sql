-- Seed 4 interactive tutorials
INSERT INTO interactive_tutorials (slug, title, description, difficulty, estimated_time, total_steps, category, xp_reward, badge_id, order_index) VALUES
('detecting-arbitrage', 'Detecting Arbitrage Opportunities', 'Learn to identify and analyze arbitrage opportunities across Solana DEXs with hands-on coding exercises', 'intermediate', 25, 8, 'searchers', 200, 'Arbitrage Detective', 1),
('building-bundles', 'Building Your First Bundle', 'Master the art of constructing atomic transaction bundles for MEV extraction', 'advanced', 30, 10, 'searchers', 250, 'Bundle Builder', 2),
('choosing-validators', 'Choosing Validators', 'Analyze validator performance and select the best validators for your MEV strategy', 'intermediate', 20, 6, 'validators', 150, 'Validator Expert', 3),
('analyzing-performance', 'Analyzing MEV Performance', 'Track and optimize your MEV bot performance with advanced analytics', 'advanced', 25, 7, 'searchers', 200, 'Analytics Pro', 4);

-- Tutorial 1: Detecting Arbitrage Opportunities (8 steps)
INSERT INTO tutorial_steps (tutorial_id, step_number, step_type, title, content, validation_rules, hints) VALUES
(1, 1, 'instruction', 'Introduction to Arbitrage', '{"text": "Arbitrage is the practice of profiting from price differences of the same asset across different markets. On Solana, opportunities arise when tokens trade at different prices on DEXs like Raydium, Orca, and Serum.", "keyPoints": ["Price differences create profit opportunities", "Speed is critical - opportunities disappear in seconds", "Must account for gas costs and slippage", "Typical profits range from 0.1% to 2%"]}', NULL, NULL),

(1, 2, 'code_playground', 'Price Comparison', '{"instructions": "Write a function that calculates the percentage price difference between two DEXs. Return positive if Orca price is higher, negative if Raydium is higher.", "starterCode": "function calculatePriceDifference(raydiumPrice, orcaPrice) {\n  // Calculate percentage difference\n  // Formula: ((orcaPrice - raydiumPrice) / raydiumPrice) * 100\n  \n}", "solution": "function calculatePriceDifference(raydiumPrice, orcaPrice) {\n  return ((orcaPrice - raydiumPrice) / raydiumPrice) * 100;\n}", "testCases": [{"input": [100, 102], "expected": 2}, {"input": [100, 98], "expected": -2}, {"input": [50, 51], "expected": 2}]}', '{"type": "code_execution", "passingTests": 3}', '["Remember: (new - old) / old * 100", "Positive means Orca is higher", "Negative means Raydium is higher"]'),

(1, 3, 'live_data', 'Analyze Real Opportunities', '{"instructions": "Examine the live MEV opportunities below and identify which one has the highest profit potential.", "dataSource": "/api/opportunities?type=arbitrage&limit=5", "task": "Select the opportunity with the highest estimated profit", "displayFields": ["token_pair", "dex_from", "dex_to", "estimated_profit_sol"]}', '{"type": "selection", "field": "estimated_profit_sol", "operator": "max"}', '["Look at the estimated_profit_sol column", "Higher profit = better opportunity", "Consider the token pair liquidity"]'),

(1, 4, 'code_playground', 'Net Profit Calculator', '{"instructions": "Calculate net profit after deducting gas costs. Return the profit in SOL.", "starterCode": "function calculateNetProfit(grossProfit, gasCost) {\n  // Subtract gas cost from gross profit\n  \n}", "solution": "function calculateNetProfit(grossProfit, gasCost) {\n  return grossProfit - gasCost;\n}", "testCases": [{"input": [0.5, 0.01], "expected": 0.49}, {"input": [0.1, 0.05], "expected": 0.05}, {"input": [0.02, 0.03], "expected": -0.01}]}', '{"type": "code_execution", "passingTests": 3}', '["Simple subtraction: profit - cost", "Result can be negative (loss)", "Always check if net profit > 0"]'),

(1, 5, 'quiz_checkpoint', 'Risk Assessment', '{"questions": [{"id": 1, "question": "What is the main risk in arbitrage?", "options": ["High gas fees", "Price changes during execution", "Low liquidity", "Validator rejection"], "correct": 1, "explanation": "Price changes during execution can eliminate profits or cause losses."}, {"id": 2, "question": "What is slippage?", "options": ["Transaction fee", "Price difference from expected", "Network delay", "Validator tip"], "correct": 1, "explanation": "Slippage is the difference between expected and actual execution price."}, {"id": 3, "question": "When should you execute arbitrage?", "options": ["Anytime", "Only when net profit > 0", "Only on weekends", "During high volume"], "correct": 1, "explanation": "Only execute when net profit (after all costs) is positive."}]}', '{"type": "quiz", "passingScore": 100}', NULL),

(1, 6, 'code_playground', 'Profitability Check', '{"instructions": "Write a function that returns true if an arbitrage opportunity is profitable after costs.", "starterCode": "function isProfitable(buyPrice, sellPrice, amount, gasCost) {\n  // Calculate gross profit\n  // Subtract gas cost\n  // Return true if net profit > 0\n  \n}", "solution": "function isProfitable(buyPrice, sellPrice, amount, gasCost) {\n  const grossProfit = (sellPrice - buyPrice) * amount;\n  const netProfit = grossProfit - gasCost;\n  return netProfit > 0;\n}", "testCases": [{"input": [100, 102, 10, 5], "expected": true}, {"input": [100, 101, 10, 15], "expected": false}, {"input": [50, 52, 20, 10], "expected": true}]}', '{"type": "code_execution", "passingTests": 3}', '["Calculate gross profit first", "Subtract gas cost", "Check if result > 0"]'),

(1, 7, 'live_data', 'Filter Profitable Opportunities', '{"instructions": "From the live opportunities, identify how many are actually profitable after gas costs (assume 0.001 SOL gas).", "dataSource": "/api/opportunities?type=arbitrage&limit=10", "task": "Count opportunities where estimated_profit_sol > 0.001", "displayFields": ["token_pair", "estimated_profit_sol"]}', '{"type": "count", "field": "estimated_profit_sol", "operator": ">", "value": 0.001}', '["Filter where profit > 0.001 SOL", "Count the remaining opportunities", "This is your profitable set"]'),

(1, 8, 'code_playground', 'Complete Arbitrage Detector', '{"instructions": "Implement a complete arbitrage detector that checks profitability and returns the best opportunity.", "starterCode": "function detectBestArbitrage(opportunities, gasCost) {\n  // Filter profitable opportunities\n  // Find the one with highest net profit\n  // Return its index or -1 if none profitable\n  \n}", "solution": "function detectBestArbitrage(opportunities, gasCost) {\n  let bestIndex = -1;\n  let bestProfit = 0;\n  \n  for (let i = 0; i < opportunities.length; i++) {\n    const netProfit = opportunities[i].profit - gasCost;\n    if (netProfit > bestProfit) {\n      bestProfit = netProfit;\n      bestIndex = i;\n    }\n  }\n  \n  return bestIndex;\n}", "testCases": [{"input": [[{"profit": 0.5}, {"profit": 0.3}], 0.1], "expected": 0}, {"input": [[{"profit": 0.01}, {"profit": 0.005}], 0.02], "expected": -1}, {"input": [[{"profit": 0.1}, {"profit": 0.2}, {"profit": 0.15}], 0.05], "expected": 1}]}', '{"type": "code_execution", "passingTests": 3}', '["Loop through all opportunities", "Calculate net profit for each", "Track the best one", "Return -1 if none profitable"]');

-- Tutorial 2: Building Your First Bundle (10 steps)
INSERT INTO tutorial_steps (tutorial_id, step_number, step_type, title, content, validation_rules, hints) VALUES
(2, 1, 'instruction', 'Bundle Basics', '{"text": "Bundles are groups of transactions that execute atomically - either all succeed or all fail. This is critical for MEV strategies that require multiple steps.", "keyPoints": ["Atomic execution prevents partial failures", "Transactions execute in your specified order", "Failed bundles don''t consume gas", "Enables complex multi-step strategies"]}', NULL, NULL),

(2, 2, 'code_playground', 'Transaction Ordering', '{"instructions": "Given an array of transactions, return them in the correct order: approvals first, then swaps, then transfers.", "starterCode": "function orderTransactions(transactions) {\n  // Sort by type: approval, swap, transfer\n  \n}", "solution": "function orderTransactions(transactions) {\n  const order = {approval: 0, swap: 1, transfer: 2};\n  return transactions.sort((a, b) => order[a.type] - order[b.type]);\n}", "testCases": [{"input": [[{"type": "swap"}, {"type": "approval"}]], "expected": [{"type": "approval"}, {"type": "swap"}]}]}', '{"type": "code_execution", "passingTests": 1}', '["Approvals must come first", "Then swaps", "Finally transfers"]'),

(2, 3, 'quiz_checkpoint', 'Bundle Knowledge Check', '{"questions": [{"id": 1, "question": "What happens if one transaction in a bundle fails?", "options": ["Others still execute", "Entire bundle fails", "It retries", "Validator decides"], "correct": 1, "explanation": "Bundles are atomic - all succeed or all fail."}]}', '{"type": "quiz", "passingScore": 100}', NULL),

(2, 4, 'code_playground', 'Gas Estimation', '{"instructions": "Calculate total gas for a bundle by summing individual transaction gas estimates and adding 20% buffer.", "starterCode": "function estimateBundleGas(transactions) {\n  // Sum all gas estimates\n  // Add 20% buffer\n  \n}", "solution": "function estimateBundleGas(transactions) {\n  const total = transactions.reduce((sum, tx) => sum + tx.gas, 0);\n  return total * 1.2;\n}", "testCases": [{"input": [[{"gas": 100}, {"gas": 200}]], "expected": 360}]}', '{"type": "code_execution", "passingTests": 1}', '["Sum all gas values", "Multiply by 1.2 for 20% buffer"]'),

(2, 5, 'instruction', 'Bundle Tips', '{"text": "Tips incentivize validators to include your bundle. Higher tips increase inclusion probability but reduce your profit.", "keyPoints": ["Tip 1-5% of expected profit", "Competitive opportunities need higher tips", "Tips go to validators", "Balance tip vs profit margin"]}', NULL, NULL),

(2, 6, 'code_playground', 'Calculate Optimal Tip', '{"instructions": "Calculate a tip that is 3% of expected profit.", "starterCode": "function calculateTip(expectedProfit) {\n  // Return 3% of profit\n  \n}", "solution": "function calculateTip(expectedProfit) {\n  return expectedProfit * 0.03;\n}", "testCases": [{"input": [1], "expected": 0.03}, {"input": [10], "expected": 0.3}]}', '{"type": "code_execution", "passingTests": 2}', '["Multiply by 0.03 for 3%"]'),

(2, 7, 'live_data', 'Analyze Bundle Success Rates', '{"instructions": "View recent bundle submissions and calculate the average success rate.", "dataSource": "/api/jito/performance", "task": "Identify the success rate percentage", "displayFields": ["total_bundles", "successful_bundles"]}', '{"type": "calculation", "formula": "successful / total * 100"}', '["Success rate = successful / total", "Multiply by 100 for percentage"]'),

(2, 8, 'instruction', 'Simulation Testing', '{"text": "Always simulate bundles before submission to catch errors and estimate outcomes.", "keyPoints": ["Use Jito simulation API", "Test with current state", "Verify all transactions succeed", "Check final profit"]}', NULL, NULL),

(2, 9, 'quiz_checkpoint', 'Final Knowledge Check', '{"questions": [{"id": 1, "question": "Why simulate bundles?", "options": ["Required", "Catch errors before submission", "Save gas", "Increase speed"], "correct": 1, "explanation": "Simulation catches errors and estimates outcomes before spending gas."}]}', '{"type": "quiz", "passingScore": 100}', NULL),

(2, 10, 'code_playground', 'Bundle Validator', '{"instructions": "Write a function that validates a bundle has correct ordering and sufficient gas.", "starterCode": "function validateBundle(bundle) {\n  // Check transactions are ordered correctly\n  // Check total gas < 1400000\n  // Return true if valid\n  \n}", "solution": "function validateBundle(bundle) {\n  const order = {approval: 0, swap: 1, transfer: 2};\n  for (let i = 1; i < bundle.length; i++) {\n    if (order[bundle[i].type] < order[bundle[i-1].type]) return false;\n  }\n  const totalGas = bundle.reduce((sum, tx) => sum + tx.gas, 0);\n  return totalGas < 1400000;\n}", "testCases": [{"input": [[{"type": "approval", "gas": 50000}, {"type": "swap", "gas": 100000}]], "expected": true}]}', '{"type": "code_execution", "passingTests": 1}', '["Check ordering", "Check gas limit", "Return boolean"]');

-- Tutorial 3: Choosing Validators (6 steps)
INSERT INTO tutorial_steps (tutorial_id, step_number, step_type, title, content, validation_rules, hints) VALUES
(3, 1, 'instruction', 'Validator Metrics', '{"text": "Choosing the right validator affects your MEV success rate and profitability.", "keyPoints": ["Skip rate < 5% is good", "MEV rewards indicate capture ability", "Uptime > 99% is critical", "Jito validators have higher success rates"]}', NULL, NULL),

(3, 2, 'live_data', 'Analyze Validator Performance', '{"instructions": "Examine live validator data and identify the validator with the lowest skip rate.", "dataSource": "/api/validators?limit=10", "task": "Find validator with minimum skip_rate", "displayFields": ["validator_name", "skip_rate", "mev_rewards"]}', '{"type": "selection", "field": "skip_rate", "operator": "min"}', '["Lower skip rate is better", "Look for < 5%"]'),

(3, 3, 'code_playground', 'Validator Scoring', '{"instructions": "Score validators based on skip rate (lower is better) and MEV rewards (higher is better).", "starterCode": "function scoreValidator(skipRate, mevRewards) {\n  // Lower skip rate = higher score\n  // Higher MEV = higher score\n  // Return combined score\n  \n}", "solution": "function scoreValidator(skipRate, mevRewards) {\n  return (100 - skipRate) + mevRewards;\n}", "testCases": [{"input": [5, 100], "expected": 195}, {"input": [10, 50], "expected": 140}]}', '{"type": "code_execution", "passingTests": 2}', '["Invert skip rate: 100 - skipRate", "Add MEV rewards", "Higher score = better validator"]'),

(3, 4, 'quiz_checkpoint', 'Validator Knowledge', '{"questions": [{"id": 1, "question": "What is a good validator skip rate?", "options": ["< 1%", "< 5%", "< 20%", "< 50%"], "correct": 1, "explanation": "Skip rate under 5% indicates reliable block production."}]}', '{"type": "quiz", "passingScore": 100}', NULL),

(3, 5, 'live_data', 'Compare Jito vs Regular', '{"instructions": "Compare MEV rewards between Jito and non-Jito validators.", "dataSource": "/api/validators?limit=20", "task": "Calculate average MEV rewards for Jito validators", "displayFields": ["validator_name", "is_jito", "mev_rewards"]}', '{"type": "average", "field": "mev_rewards", "filter": {"is_jito": true}}', '["Filter for is_jito = true", "Calculate average of mev_rewards"]'),

(3, 6, 'code_playground', 'Select Best Validators', '{"instructions": "From an array of validators, return the top 3 by score.", "starterCode": "function selectTopValidators(validators, count) {\n  // Sort by score descending\n  // Return top count validators\n  \n}", "solution": "function selectTopValidators(validators, count) {\n  return validators.sort((a, b) => b.score - a.score).slice(0, count);\n}", "testCases": [{"input": [[{"score": 100}, {"score": 200}, {"score": 150}], 2], "expected": [{"score": 200}, {"score": 150}]}]}', '{"type": "code_execution", "passingTests": 1}', '["Sort descending by score", "Take first count items"]');

-- Tutorial 4: Analyzing MEV Performance (7 steps)
INSERT INTO tutorial_steps (tutorial_id, step_number, step_type, title, content, validation_rules, hints) VALUES
(4, 1, 'instruction', 'Performance Metrics', '{"text": "Track key metrics to optimize your MEV strategy.", "keyPoints": ["Success rate: % of profitable executions", "Average profit per trade", "Gas efficiency: profit / gas ratio", "ROI: return on investment"]}', NULL, NULL),

(4, 2, 'code_playground', 'Calculate Success Rate', '{"instructions": "Calculate success rate as percentage of successful trades.", "starterCode": "function calculateSuccessRate(successful, total) {\n  // Return percentage\n  \n}", "solution": "function calculateSuccessRate(successful, total) {\n  return (successful / total) * 100;\n}", "testCases": [{"input": [80, 100], "expected": 80}, {"input": [45, 50], "expected": 90}]}', '{"type": "code_execution", "passingTests": 2}', '["Divide successful by total", "Multiply by 100"]'),

(4, 3, 'live_data', 'Analyze Your Performance', '{"instructions": "View your recent MEV performance statistics.", "dataSource": "/api/profit/statistics", "task": "Identify your average profit per opportunity", "displayFields": ["total_opportunities", "successful_count", "average_profit"]}', '{"type": "display"}', '["Look at average_profit field"]'),

(4, 4, 'code_playground', 'Calculate ROI', '{"instructions": "Calculate ROI as (profit - cost) / cost * 100.", "starterCode": "function calculateROI(profit, cost) {\n  // Return ROI percentage\n  \n}", "solution": "function calculateROI(profit, cost) {\n  return ((profit - cost) / cost) * 100;\n}", "testCases": [{"input": [150, 100], "expected": 50}, {"input": [200, 100], "expected": 100}]}', '{"type": "code_execution", "passingTests": 2}', '["ROI = (profit - cost) / cost * 100"]'),

(4, 5, 'quiz_checkpoint', 'Performance Knowledge', '{"questions": [{"id": 1, "question": "What is a good MEV success rate?", "options": ["10-20%", "40-60%", "70-80%", "95%+"], "correct": 2, "explanation": "A good MEV bot achieves 70-80% success rate."}]}', '{"type": "quiz", "passingScore": 100}', NULL),

(4, 6, 'code_playground', 'Gas Efficiency', '{"instructions": "Calculate gas efficiency as profit per unit of gas.", "starterCode": "function calculateGasEfficiency(profit, gasUsed) {\n  // Return profit / gas\n  \n}", "solution": "function calculateGasEfficiency(profit, gasUsed) {\n  return profit / gasUsed;\n}", "testCases": [{"input": [1, 0.01], "expected": 100}, {"input": [0.5, 0.005], "expected": 100}]}', '{"type": "code_execution", "passingTests": 2}', '["Simply divide profit by gas"]'),

(4, 7, 'instruction', 'Optimization Strategies', '{"text": "Use performance data to optimize your MEV strategy.", "keyPoints": ["Focus on high success rate opportunities", "Eliminate low-profit strategies", "Optimize gas usage", "Adjust tips based on competition"]}', NULL, NULL);
